回溯算法

回溯算法实质上是对一个N叉树的遍历。遍历这个树时需要考虑：
如何选择访问路径;
每个节点可供的选择有哪些;
何时终止访问。

回溯算法的框架如下：

result = []
backtrack(路径, 选择列表)
    if 满足结束条件
        result.add(路径)
        return

    for 选择 in 选择列表
        做选择
        backtrack(路径, 选择列表)
        撤销选择

典型问题：

全排列
该类型的题目通常要求列出所有备选元素以某种顺序的全排列（最常见的是字典续）。
解决该类问题的方法是：
  首先，将所有备选元素以要求的顺序排列；
  接着，使用回溯算法生成所有的全排列。
需要一个额外的访问数组，以供做可选性判断。


### 8皇后 ###
棋盘上的每一行可以视为决策树上的一层，该行上的每一格是可控的选择。其为代码如下：
void dfs(int size, int row)
    // 触发结束条件
    if row == size
        // 遍历结束，找到一种布局
        return

    for col = 0 to size
        // 排除不合法选择
        if (!isValid(size, row, col)) 
            continue;
        // 做选择
        select(row, col)
        // 进入下一行决策
        dfs(size, row + 1)
        // 撤销选择
        cancel(row, col)
    }
}

此处作出选择和排除不合法选择的方式不知一种。
之一：
为棋盘大小做一个映射图board[N][N]对应棋盘上的每一个格子。如果i行j列放上了皇后，则
将board[i-1][j-1]置为1,以表示做出选择，撤销选择便是将该位清零。排除不合法选择时，
需要检查同列前几行、左上方以及右上方是否有被置为1的格子。
这种做法逻辑比较清晰，但是缺点是判断选择是否合法时需要额外增加一级循环遍历。
之二：
仅记录每一列和每一条对角线的空闲情况。列的空闲可以用数组vc[N]记录，可以用当前格子
的列编号j索引；左对角线上每一个格子的纵横坐标和都相等，因此可以用行列编号之和索引
i+j；右对角线上的每个格子的纵横坐标之差是个常数，为避免出现负数，需要额外加上N。
